inductive Program : U0 -> U1 where
	Dyn : ^(List a) -> Program a
	Filter : ^(a ~> Bool) -> Program a -> Program a
	Map    : ^(a ~> b) -> Program a -> Program b

compose : ^(b ~> c) -> ^(a ~> b) -> ^(a ~> c)
compose f g = <\x => ~f (~g x)>

combine : ^(a ~> b) -> Program a -> Program b
combine f p = case p
	ListOf xs      => Map f (ListOf xs)
	Filter pred p1 => Map f (Filter pred (optimize p1))
	Map f p1       => combine (compose f g) p1

optimize : Program a -> Program a
optimize p = case p
	ListOf xs      => ListOf xs
	Filter pred p1 => Filter pred (optimize p1)
	Map f p1       => combine f p1

forIn : List a ~> (Unit ~> Unit) ~> Unit
forIn xs body = case xs
	empty     => unit
	cons x xs => block
		body unit
		forIn xs body

run : Program a -> ^(List a)
run p = case p
	ListOf xs => xs
	Filter pred p1 = block
		var xs = newList unit
		forIn (run p1) \x =>
			if ~pred ~x
			then xs.push x
			else unit
		xs
	Map f p1 = block
		var xs = newList unit
		forIn ~(run p1) \x =>
			xs.push (~f x)
		xs